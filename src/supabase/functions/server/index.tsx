/* AUTOGENERATED FILE - DO NOT EDIT CONTENTS */ /* Table schema:
CREATE TABLE kv_store_6ead2a10 (
  key TEXT NOT NULL PRIMARY KEY,
  value JSONB NOT NULL
);
*/ // View at https://supabase.com/dashboard/project/kjksyigqsvrpowxodnim/database/tables
// This file provides a simple key-value interface for storing Figma Make data. It should be adequate for most small-scale use cases.
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'npm:@supabase/supabase-js@2';
import { cors } from "npm:hono/cors";
import { Hono } from "npm:hono";
import { logger } from "npm:hono/logger";
import OpenAI from 'npm:openai';
import * as kv from './kv_store.tsx';
// --- IMPORTS for reliable file parsing ---
import pdf from "npm:pdf-parse";
import mammoth from "npm:mammoth";
const app = new Hono();
app.use('*', cors({
  origin: '*',
  allowMethods: [
    'GET',
    'POST',
    'PUT',
    'DELETE',
    'OPTIONS'
  ],
  allowHeaders: [
    'Content-Type',
    'Authorization'
  ]
}));
app.use('*', logger(console.log));
// Initialize Supabase clients
const supabaseUrl = Deno.env.get('SUPABASE_URL');
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');
const HUGGING_FACE_TOKEN = Deno.env.get('HUGGING_FACE_TOKEN');
const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY');
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY
});
const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);
const supabase = createClient(supabaseUrl, supabaseAnonKey);
// --- Scoring Logic using Hugging Face API ---
async function calculateSimilarityScores(resumeText, requirements) {
  console.log("DEBUG: Starting CHUNK-BASED similarity scoring...");
  // 1. Split the resume into smaller, more meaningful chunks (sentences).
  const resumeChunks = resumeText.split(/[.!?]/g).filter((s)=>s.trim().length > 10);
  console.log(`DEBUG: Split resume into ${resumeChunks.length} chunks.`);
  const allScores = [];
  // 2. For each requirement, find the best matching chunk in the resume.
  for (const requirement of requirements){
    const response = await fetch("https://api-inference.huggingface.co/models/sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2", {
      headers: {
        'Authorization': `Bearer ${HUGGING_FACE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      method: "POST",
      body: JSON.stringify({
        inputs: {
          // Compare the single requirement against ALL resume chunks at once.
          source_sentence: requirement,
          sentences: resumeChunks
        },
        options: {
          wait_for_model: true
        }
      })
    });
    if (!response.ok) {
      const errorBody = await response.text();
      console.error("DEBUG: Hugging Face API Error Response:", errorBody);
      throw new Error(`Hugging Face API error for requirement: "${requirement}"`);
    }
    const chunkSimilarities = await response.json();
    if (!Array.isArray(chunkSimilarities)) {
      throw new Error("Invalid response format from Hugging Face API");
    }
    // 3. The score for the requirement is the HIGHEST score found among all chunks.
    const bestScore = Math.max(...chunkSimilarities, 0);
    allScores.push(bestScore);
    console.log(`DEBUG: Best score for "${requirement}" is ${(bestScore * 100).toFixed(2)}%`);
  }
  return allScores;
}
function extractRequirements(job) {
  const requirements = [];
  // if (job.assessmentConfiguration) {
  //   const config = job.assessmentConfiguration;
  //   if (config.selectedTechnicalSubSkills) requirements.push(...config.selectedTechnicalSubSkills);
  //   if (config.selectedSoftSkillsSubAreas) requirements.push(...config.selectedSoftSkillsSubAreas);
  //   if (config.customTechnicalSkills) requirements.push(...config.customTechnicalSkills.split('\n').filter((s)=>s.trim()));
  //   if (config.customSoftSkills) requirements.push(...config.customSoftSkills.split('\n').filter((s)=>s.trim()));
  // }
  // if (job.requiredSkills) {
  //   if (job.requiredSkills.technical) requirements.push(...job.requiredSkills.technical);
  //   if (job.requiredSkills.softSkills) requirements.push(...job.requiredSkills.softSkills);
  //   if (job.requiredSkills.software) requirements.push(...job.requiredSkills.software);
  // }
  if (job.requirements) requirements.push(...job.requirements);
  return [
    ...new Set(requirements)
  ].filter((req)=>req && req.trim().length > 0);
}
async function updateApplicationScore(applicationKey, scoreData) {
  const application = await kv.get(applicationKey);
  if (application) {
    application.resumeScore = scoreData;
    application.resumeScoreStatus = 'completed';
    await kv.set(applicationKey, application);
  }
}
// --- CHANGED SECTION ---
// The function no longer needs userId, as all required data is on the application object.
async function scoreResumeInBackground(applicationKey, positionId) {
  console.log(`DEBUG: Starting background scoring for application: ${applicationKey}`);
  try {
    // 1. Fetch the job details to get the requirements
    const job = await kv.get(`job-position:${positionId}`);
    if (!job) throw new Error(`Failed to fetch job: ${positionId}`);
    console.log("DEBUG: Successfully fetched job details.");
    // 2. Fetch the specific application to get the correct resume text
    const application = await kv.get(applicationKey);
    if (!application) throw new Error(`Failed to fetch application: ${applicationKey}`);
    if (!application.resumeText) throw new Error('No resume text available in application');
    console.log("DEBUG: Successfully fetched application with resume text.");
    // 3. Extract all requirements from the job data
    const requirements = extractRequirements(job);
    if (requirements.length === 0) {
      console.log("DEBUG: No requirements found for this job. Setting default score.");
      await updateApplicationScore(applicationKey, {
        success: true,
        overallScore: 50,
        sectionScores: [],
        analysis: {
          overallScore: 50,
          strengths: [],
          improvements: [],
          detailedScores: [],
          message: "No specific requirements found for this position"
        }
      });
      return;
    }
    console.log(`DEBUG: Extracted ${requirements.length} requirements.`);
    const resumeText = application.resumeText;
    console.log("DEBUG: Resume text length:", resumeText.length);
    // 4. Get similarity scores from the AI model
    const similarities = await calculateSimilarityScores(resumeText, requirements);
    if (!similarities || similarities.length !== requirements.length) {
      throw new Error("Mismatch between requirements and returned similarity scores");
    }
    console.log("DEBUG: Similarity scores processed successfully.");
    // 5. Process the scores into a final result
    const sectionScores = requirements.map((req, index)=>{
      const similarity = similarities[index];
      const score = Math.max(0, Math.min(100, Math.round(similarity * 100)));
      return {
        requirement: req,
        score: score,
        matchPercentage: score
      };
    });
    const totalScore = sectionScores.reduce((sum, item)=>sum + item.score, 0);
    const finalScore = Math.round(totalScore / sectionScores.length);
    console.log(`DEBUG: Calculated final score: ${finalScore}%`);
    const strengths = sectionScores.filter((s)=>s.score >= 70).map((s)=>s.requirement);
    const improvements = sectionScores.filter((s)=>s.score < 40).map((s)=>s.requirement);
    const scoreData = {
      success: true,
      overallScore: finalScore,
      analysis: {
        strengths: strengths,
        improvements: improvements,
        detailedScores: sectionScores
      }
    };
    // 6. Save the final score back to the application object
    await updateApplicationScore(applicationKey, scoreData);
    console.log(`DEBUG: Successfully saved score for application: ${applicationKey}`);
  } catch (error) {
    // If anything above fails, catch the error and mark the scoring as 'failed'
    console.error('Background resume scoring failed:', error);
    const application = await kv.get(applicationKey);
    if (application) {
      application.resumeScoreStatus = 'failed';
      application.resumeScore = {
        success: false,
        error: error.message,
        overallScore: 0,
        analysis: {
          overallScore: 0
        }
      };
      await kv.set(applicationKey, application);
    }
  }
}
// --- Helper Functions ---
const initializeBuckets = async ()=>{
  const bucketName = 'make-6ead2a10-resumes';
  try {
    const { data: buckets } = await supabaseAdmin.storage.listBuckets();
    const bucketExists = buckets?.some((bucket)=>bucket.name === bucketName);
    if (!bucketExists) {
      const { error } = await supabaseAdmin.storage.createBucket(bucketName, {
        public: false,
        allowedMimeTypes: [
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        ],
        fileSizeLimit: 5242880 // 5MB
      });
      if (error) console.error('Error creating bucket:', error);
      else console.log('Resume bucket created successfully');
    }
  } catch (error) {
    console.error('Error initializing buckets:', error);
  }
};
const getByPrefixWithKeys = async (prefix)=>{
  const supabaseClient = createClient(Deno.env.get('SUPABASE_URL'), Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'));
  const { data, error } = await supabaseClient.from('kv_store_6ead2a10').select('key, value').like('key', prefix + '%');
  if (error) throw new Error(error.message);
  return data || [];
};
const extractTextFromFile = async (file)=>{
  try {
    console.log("DEBUG: Starting text extraction with robust libraries for file:", file.name, "Type:", file.type);
    const arrayBuffer = await file.arrayBuffer();
    let text = "";
    switch(file.type){
      case 'application/pdf':
        const pdfData = await pdf(arrayBuffer);
        text = pdfData.text;
        break;
      case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
        const docxData = await mammoth.extractRawText({
          arrayBuffer
        });
        text = docxData.value;
        break;
      case 'application/msword':
        console.warn("Attempting to parse legacy .doc format. Results may vary.");
        try {
          const docData = await mammoth.extractRawText({
            arrayBuffer
          });
          text = docData.value;
        } catch (docError) {
          console.error("Could not parse .doc file. It might be unsupported.", docError.message);
          throw new Error("Legacy .doc file format is not fully supported. Please convert to DOCX or PDF.");
        }
        break;
      case 'text/plain':
        text = new TextDecoder().decode(new Uint8Array(arrayBuffer));
        break;
      default:
        console.warn("Unsupported file type:", file.type);
        throw new Error(`Unsupported file format: ${file.type}. Please upload PDF or DOCX.`);
    }
    if (!text || text.trim().length < 20) {
      throw new Error("Extracted text was empty or too short. The document may be image-based or corrupt.");
    }
    const cleanedText = text.replace(/\s+/g, ' ').trim();
    console.log(`DEBUG: Successfully extracted text. Length: ${cleanedText.length}. Sample: ${cleanedText.substring(0, 150)}...`);
    return cleanedText;
  } catch (error) {
    console.error('Error extracting text from file:', error);
    throw new Error(`Failed to parse the resume file: ${error.message}`);
  }
};
const verifyAdminRole = async (accessToken)=>{
  if (!accessToken) return {
    isAdmin: false,
    user: null,
    error: 'No access token provided'
  };
  try {
    const { data: { user }, error } = await supabaseAdmin.auth.getUser(accessToken);
    if (error || !user?.id) return {
      isAdmin: false,
      user: null,
      error: 'Invalid access token'
    };
    let profile = await kv.get(`profile:${user.id}`);
    if (!profile) {
      profile = {
        name: user.user_metadata?.name || user.email?.split('@')[0],
        email: user.email,
        role: 'candidate',
        createdAt: new Date().toISOString()
      };
      await kv.set(`profile:${user.id}`, profile);
    }
    return {
      isAdmin: profile.role === 'admin',
      user,
      error: null
    };
  } catch (error) {
    console.error('Admin verification error:', error);
    return {
      isAdmin: false,
      user: null,
      error: 'Failed to verify admin role'
    };
  }
};
// --- Main Server Endpoints ---
app.post('/make-server-6ead2a10/apply-for-job', async (c)=>{
  try {
    const { userId, positionId, resumeUrl, resumeText } = await c.req.json();
    if (!userId || !positionId || !resumeText) {
      return c.json({
        error: 'User ID, Position ID, and Resume Text are required'
      }, 400);
    }
    const applicationKey = `job-application:${positionId}:${userId}`;
    // Create the application with a complete and consistent structure from the start
    const applicationData = {
      userId,
      positionId,
      appliedAt: new Date().toISOString(),
      status: 'pending',
      resumeUrl,
      resumeText,
      resumeScoreStatus: 'pending',
      // --- ADD THESE FIELDS ---
      scores: {
        softSkills: 0,
        technical: 0,
        weighted: 0
      },
      assessmentStatus: {
        softSkills: 'not_started',
        technical: 'not_started'
      },
      assessmentReport: {}
    };
    await kv.set(applicationKey, applicationData);
    // Start the resume scoring in the background
    scoreResumeInBackground(applicationKey, positionId);
    return c.json({
      success: true,
      application: applicationData
    });
  } catch (error) {
    console.error('Apply for job error:', error);
    return c.json({
      error: 'Failed to apply for job'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/signup', async (c)=>{
  try {
    const { email, password, name, role = 'candidate' } = await c.req.json();
    if (!email || !password || !name) return c.json({
      error: 'Email, password, and name are required'
    }, 400);
    if (role !== 'candidate') return c.json({
      error: 'Only candidate accounts can be created through public signup'
    }, 400);
    const { data, error } = await supabaseAdmin.auth.admin.createUser({
      email,
      password,
      user_metadata: {
        name
      },
      email_confirm: true
    });
    if (error) throw error;
    if (data.user) {
      await kv.set(`profile:${data.user.id}`, {
        name,
        email,
        role,
        createdAt: new Date().toISOString()
      });
    }
    return c.json({
      success: true,
      user: data.user
    });
  } catch (error) {
    console.error('Signup error:', error);
    return c.json({
      error: error.message
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-user-role', async (c)=>{
  try {
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    let profile = await kv.get(`profile:${userId}`);
    if (!profile) {
      const { data: { user }, error } = await supabaseAdmin.auth.admin.getUserById(userId);
      if (error || !user) throw new Error('User not found');
      profile = {
        name: user.user_metadata?.name || user.email?.split('@')[0],
        email: user.email,
        role: 'candidate',
        createdAt: new Date().toISOString()
      };
      await kv.set(`profile:${userId}`, profile);
    }
    return c.json({
      role: profile.role || 'candidate'
    });
  } catch (error) {
    console.error('Get user role error:', error);
    return c.json({
      error: error.message
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-profile', async (c)=>{
  try {
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    const profile = await kv.get(`profile:${userId}`);
    return c.json({
      profile
    });
  } catch (error) {
    console.error('Get profile error:', error);
    return c.json({
      error: 'Failed to retrieve profile'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/save-profile', async (c)=>{
  try {
    const { userId, profile } = await c.req.json();
    if (!userId || !profile) return c.json({
      error: 'User ID and profile data are required'
    }, 400);
    profile.updatedAt = new Date().toISOString();
    await kv.set(`profile:${userId}`, profile);
    return c.json({
      success: true
    });
  } catch (error) {
    console.error('Save profile error:', error);
    return c.json({
      error: 'Failed to save profile'
    }, 500);
  }
});
app.get('/make-server-6ead2a10/get-job-positions', async (c)=>{
  try {
    const positions = await getByPrefixWithKeys('job-position:');
    const positionsData = positions.map((p)=>({
        id: p.key.split(':')[1],
        ...p.value
      })).filter(Boolean);
    return c.json({
      positions: positionsData
    });
  } catch (error) {
    console.error('Get job positions error:', error);
    return c.json({
      error: 'Failed to retrieve job positions'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-job-position', async (c)=>{
  try {
    const { positionId } = await c.req.json();
    if (!positionId) return c.json({
      error: 'Position ID is required'
    }, 400);
    const position = await kv.get(`job-position:${positionId}`);
    if (!position) return c.json({
      error: 'Job position not found'
    }, 404);
    return c.json({
      position: {
        id: positionId,
        ...position
      }
    });
  } catch (error) {
    console.error('Get job position error:', error);
    return c.json({
      error: 'Failed to retrieve job position'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/save-job-position', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin, user } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId, position } = await c.req.json();
    if (!position) return c.json({
      error: 'Position data is required'
    }, 400);
    // Keep the validation to ensure the main requirements field is always present
    if (!position.requirements || !Array.isArray(position.requirements) || position.requirements.length === 0) {
      return c.json({
        error: 'The requirements field is missing or empty. Please provide at least one requirement.'
      }, 400);
    }
    const id = positionId || `pos_${Date.now()}`;
    const positionData = {
      ...position,
      id,
      createdAt: position.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      createdBy: user.id
    };
    await kv.set(`job-position:${id}`, positionData);
    return c.json({
      success: true,
      position: positionData
    });
  } catch (error) {
    console.error('Save job position error:', error);
    return c.json({
      error: 'Failed to save job position'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/delete-job-position', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId } = await c.req.json();
    if (!positionId) return c.json({
      error: 'Position ID is required'
    }, 400);
    await kv.del(`job-position:${positionId}`);
    const applications = await getByPrefixWithKeys(`job-application:${positionId}:`);
    for (const app of applications)if (app.key) await kv.del(app.key);
    return c.json({
      success: true
    });
  } catch (error) {
    console.error('Delete job position error:', error);
    return c.json({
      error: 'Failed to delete job position'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/upload-resume', async (c)=>{
  try {
    const formData = await c.req.formData();
    const file = formData.get('resume');
    const userId = formData.get('userId');
    if (!file || !userId) return c.json({
      error: 'Resume file and user ID are required'
    }, 400);
    const fileExtension = file.name.split('.').pop();
    const fileName = `resume_${Date.now()}.${fileExtension}`;
    const filePath = `${userId}/${fileName}`;
    const fileBuffer = await file.arrayBuffer();
    const { error: uploadError } = await supabaseAdmin.storage.from('make-6ead2a10-resumes').upload(filePath, fileBuffer, {
      contentType: file.type,
      upsert: true
    });
    if (uploadError) throw uploadError;
    const resumeText = await extractTextFromFile(file);
    const profile = await kv.get(`profile:${userId}`) || {};
    // Note: We still update the profile's resume_text for convenience,
    // but the application scoring no longer depends on it.
    Object.assign(profile, {
      resumeUrl: filePath,
      resumeFileName: file.name,
      resumeUploadedAt: new Date().toISOString(),
      resume_text: resumeText
    });
    await kv.set(`profile:${userId}`, profile);
    // --- CHANGED SECTION ---
    // Return the extracted text along with the URL.
    return c.json({
      success: true,
      resumeUrl: filePath,
      resumeText: resumeText
    });
  } catch (error) {
    console.error('Upload resume error:', error);
    return c.json({
      error: error.message
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-user-applications', async (c)=>{
  try {
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    const allApplications = await getByPrefixWithKeys('job-application:');
    const userApplications = allApplications.filter((app)=>app.value?.userId === userId);
    const applicationsWithPositions = await Promise.all(userApplications.map(async (app)=>{
      if (app.value && app.value.positionId) {
        const position = await kv.get(`job-position:${app.value.positionId}`);
        return {
          ...app.value,
          position: position ? {
            id: app.value.positionId,
            ...position
          } : null
        };
      }
      return null;
    }));
    return c.json({
      applications: applicationsWithPositions.filter(Boolean)
    });
  } catch (error) {
    console.error('Get user applications error:', error);
    return c.json({
      error: 'Failed to retrieve applications'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-ranked-candidates', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId } = await c.req.json();
    if (!positionId) return c.json({
      error: 'Position ID is required'
    }, 400);
    const position = await kv.get(`job-position:${positionId}`);
    if (!position) return c.json({
      error: 'Job position not found'
    }, 404);
    const applications = await getByPrefixWithKeys(`job-application:${positionId}:`);
    const candidates = await Promise.all(applications.map(async (app)=>{
      if (app.value?.userId) {
        const { userId } = app.value;
        const profile = await kv.get(`profile:${userId}`);
        // Directly use the scores from the application data
        const scores = app.value.scores || {
          softSkills: 0,
          technical: 0,
          weighted: 0
        };
        return {
          userId,
          profile,
          application: app.value,
          scores,
          resumeScore: app.value.resumeScore
        };
      }
      return null;
    }));
    const rankedCandidates = candidates.filter(Boolean).sort((a, b)=>(b.scores.weighted || 0) - (a.scores.weighted || 0));
    return c.json({
      position: {
        id: positionId,
        ...position
      },
      candidates: rankedCandidates,
      totalCandidates: rankedCandidates.length
    });
  } catch (error) {
    console.error('Get ranked candidates error:', error);
    return c.json({
      error: 'Failed to retrieve ranked candidates'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-resume-url', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    const profile = await kv.get(`profile:${userId}`);
    if (!profile?.resumeUrl) return c.json({
      error: 'No resume found'
    }, 404);
    const { data, error: urlError } = await supabaseAdmin.storage.from('make-6ead2a10-resumes').createSignedUrl(profile.resumeUrl, 3600);
    if (urlError) throw urlError;
    return c.json({
      resumeUrl: data.signedUrl
    });
  } catch (error) {
    console.error('Get resume URL error:', error);
    return c.json({
      error: 'Failed to get resume URL'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/update-application-status', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin, user } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { userId, positionId, status } = await c.req.json();
    if (!userId || !positionId || !status) return c.json({
      error: 'User ID, position ID, and status are required'
    }, 400);
    const application = await kv.get(`job-application:${positionId}:${userId}`);
    if (!application) return c.json({
      error: 'Application not found'
    }, 404);
    Object.assign(application, {
      status,
      updatedAt: new Date().toISOString(),
      updatedBy: user.id
    });
    await kv.set(`job-application:${positionId}:${userId}`, application);
    return c.json({
      success: true,
      application
    });
  } catch (error) {
    console.error('Update application status error:', error);
    return c.json({
      error: 'Failed to update application status'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/update-job-status', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId, status } = await c.req.json();
    if (!positionId || !status) return c.json({
      error: 'Position ID and status are required'
    }, 400);
    const position = await kv.get(`job-position:${positionId}`);
    if (!position) return c.json({
      error: 'Job position not found'
    }, 404);
    position.status = status;
    position.updatedAt = new Date().toISOString();
    await kv.set(`job-position:${positionId}`, position);
    return c.json({
      success: true,
      position
    });
  } catch (error) {
    console.error('Update job status error:', error);
    return c.json({
      error: 'Failed to update job status'
    }, 500);
  }
});
// --- NEW ENDPOINT 1: Start the Assessment ---
app.post('/make-server-6ead2a10/start-assessment', async (c)=>{
  try {
    const { userId, positionId, assessmentType } = await c.req.json();
    const applicationKey = `job-application:${positionId}:${userId}`;
    // 1. Fetch job and application data
    const job = await kv.get(`job-position:${positionId}`);
    const application = await kv.get(applicationKey);
    if (!job || !application || !application.resumeText) {
      throw new Error('Job or application data not found.');
    }
    // 2. Determine which skills to use based on the assessment type
    let assessmentCriteria = [];
    if (job.assessmentConfiguration) {
      if (assessmentType === 'soft-skills') {
        if (job.assessmentConfiguration.selectedSoftSkillsSubAreas) {
          assessmentCriteria.push(...job.assessmentConfiguration.selectedSoftSkillsSubAreas);
        }
        if (job.assessmentConfiguration.customSoftSkills) {
          assessmentCriteria.push(...job.assessmentConfiguration.customSoftSkills.split('\n').filter((s)=>s.trim()));
        }
      } else if (assessmentType === 'technical') {
        if (job.assessmentConfiguration.selectedTechnicalSubSkills) {
          assessmentCriteria.push(...job.assessmentConfiguration.selectedTechnicalSubSkills);
        }
        if (job.assessmentConfiguration.customTechnicalSkills) {
          assessmentCriteria.push(...job.assessmentConfiguration.customTechnicalSkills.split('\n').filter((s)=>s.trim()));
        }
      }
    }
    // 3. Create a new assessment session
    const sessionKey = `assessment-session:${applicationKey}:${assessmentType}`; // Make session key unique
    const session = {
      jobRole: job.title,
      assessmentCriteria: assessmentCriteria,
      resumeText: application.resumeText,
      conversationHistory: [],
      questionCount: 0,
      assessmentType: assessmentType
    };
    // 4. Get the FIRST question from the AI
    const aiResponse = await callOpenAIAssessment('next_action', session);
    session.lastQuestion = aiResponse.question;
    await kv.set(sessionKey, session);
    return c.json({
      sessionKey,
      firstQuestion: aiResponse.question
    });
  } catch (error) {
    console.error('Error starting assessment:', error);
    return c.json({
      error: 'Failed to start assessment'
    }, 500);
  }
});
// --- NEW ENDPOINT 2: Handle Each Answer ---
app.post('/make-server-6ead2a10/submit-answer', async (c)=>{
  try {
    const { sessionKey, answer } = await c.req.json();
    const session = await kv.get(sessionKey);
    if (!session) {
      throw new Error('Assessment session not found or has expired.');
    }
    // 1. Update conversation history
    session.conversationHistory.push({
      speaker: 'ai',
      text: session.lastQuestion || ''
    });
    session.conversationHistory.push({
      speaker: 'user',
      text: answer
    });
    session.questionCount += 1;
    // 2. Check if the assessment is complete
    if (session.questionCount >= 10) {
      const report = await callOpenAIAssessment('generate_report', session);
      const applicationKey = sessionKey.replace(`assessment-session:`, '').replace(`:${session.assessmentType}`, '');
      const application = await kv.get(applicationKey);
      if (application) {
        // Initialize fields if they don't exist
        if (!application.assessmentStatus) {
          application.assessmentStatus = {
            softSkills: 'not_started',
            technical: 'not_started'
          };
        }
        if (!application.scores) {
          application.scores = {
            softSkills: 0,
            technical: 0,
            weighted: 0
          };
        }
        if (!application.assessmentReport) {
          application.assessmentReport = {};
        }
        // Update status, report, and scores for the specific assessment type
        if (session.assessmentType === 'soft-skills') {
          application.assessmentStatus.softSkills = 'completed';
          application.scores.softSkills = report.overallScore;
          application.assessmentReport.softSkills = report;
        } else if (session.assessmentType === 'technical') {
          application.assessmentStatus.technical = 'completed';
          application.scores.technical = report.overallScore;
          application.assessmentReport.technical = report;
        }
        // Recalculate the weighted score
        const job = await kv.get(`job-position:${application.positionId}`);
        const weights = job?.assessmentWeights || {
          softSkills: 50,
          technical: 50
        };
        const weightedScore = application.scores.softSkills * (weights.softSkills / 100) + application.scores.technical * (weights.technical / 100);
        application.scores.weighted = parseFloat(weightedScore.toFixed(1));
        await kv.set(applicationKey, application);
      }
      await kv.del(sessionKey); // Clean up the session
      return c.json({
        status: 'completed'
      });
    } else {
      // 3. If not complete, get the next question
      const aiResponse = await callOpenAIAssessment('next_action', session);
      session.lastQuestion = aiResponse.question;
      await kv.set(sessionKey, session);
      return c.json({
        status: 'in_progress',
        nextQuestion: aiResponse.question
      });
    }
  } catch (error) {
    console.error('Error submitting answer:', error);
    return c.json({
      error: 'Failed to process answer'
    }, 500);
  }
});
async function callOpenAIAssessment(task, session) {
  const messages = [];
  let system_prompt = "";
  if (task === 'next_action') {
    const remainingSkills = session.assessmentCriteria.filter((skill)=>!session.conversationHistory.some((turn)=>turn.text.toLowerCase().includes(skill.toLowerCase())));
    system_prompt = `You are a sharp, experienced senior hiring manager conducting a ${session.assessmentType} assessment for the role of '${session.jobRole}'. Your goal is to deeply evaluate a candidate's skills, not just ask superficial questions.

        **SKILLS TO ASSESS:**
        - All skills to cover: ${session.assessmentCriteria.join(', ')}
        - Skills you have NOT asked about yet: ${remainingSkills.join(', ') || 'All skills have been touched on. Ask a final, challenging follow-up question.'}

        **YOUR RULES:**
        1.  **NO REPETITION:** Review the entire conversation history. It is critical that you DO NOT ask a question that is similar to one already asked.
        2.  **PROBE FOR DEPTH:** If a candidate's answer is vague, generic, or lacks specific details (e.g., "I solved a problem by thinking about it"), you MUST ask a follow-up question to probe for specifics. Do not move on until you get a concrete example or the candidate fails to provide one.
        3.  **STRATEGIC QUESTIONING:** Prioritize asking about a skill from the "Skills you have NOT asked about yet" list.
        4.  **ONE QUESTION AT A TIME:** Ask only a single, clear, open-ended question.
        5.  **JSON FORMAT:** Your response MUST BE a valid JSON object with a single key "question".`;
    if (session.assessmentType === 'soft-skills') {
      system_prompt += `\n- Frame your questions as scenario-based behavioral questions using the STAR method format (e.g., "Tell me about a time when...", "Describe a situation where...").`;
    } else if (session.assessmentType === 'technical') {
      system_prompt += `\n- Frame your questions as technical problem-solving challenges, code analysis tasks, or system design discussions.`;
    }
    messages.push({
      role: "system",
      content: system_prompt
    });
    // Add the conversation history to the messages array
    session.conversationHistory.forEach((turn)=>{
      messages.push({
        role: turn.speaker === 'ai' ? 'assistant' : 'user',
        content: turn.text
      });
    });
  } else {
    system_prompt = `You are a strict but fair AI evaluator. Your task is to critically analyze an interview transcript and provide a score based on concrete evidence.

        **ASSESSMENT CRITERIA:** ${session.assessmentCriteria.join(', ')}

        **GRADING RUBRIC:**
        - **Excellent (90-100):** Answer uses the STAR method (Situation, Task, Action, Result) with specific details and quantifiable outcomes.
        - **Good (70-89):** Answer is relevant but may lack some specific details or clear impact.
        - **Average (50-69):** Answer is generic, hypothetical, or lacks a concrete example.
        - **Poor (0-49):** Answer is evasive, irrelevant, or shows no evidence of the skill.

        **CRITICAL RULE:** An answer like "Some challenge happened. I can't remember specifics. I thought about it and made a call. The outcome was whatever." demonstrates ZERO skill. It is a non-answer and MUST receive a score below 20 for that skill. Do not give points for vague responses.
        
        **YOUR TASK:**
        - Analyze the entire conversation provided by the user.
        - Evaluate the candidate's responses against the GRADING RUBRIC.
        - Be critical. Justify low scores by pointing to the lack of specific evidence.
        - Provide a final report as a JSON object with the specified structure.`;
    messages.push({
      role: "system",
      content: system_prompt
    });
    const fullTranscript = session.conversationHistory.map((turn)=>`${turn.speaker}: ${turn.text}`).join('\n');
    messages.push({
      role: 'user',
      content: `**CANDIDATE'S RESUME:**\n${session.resumeText}\n\n**FULL INTERVIEW TRANSCRIPT:**\n${fullTranscript}`
    });
  }
  const completion = await openai.chat.completions.create({
    messages: messages,
    model: "gpt-4o",
    response_format: {
      type: "json_object"
    }
  });
  try {
    return JSON.parse(completion.choices[0].message.content);
  } catch (e) {
    console.error("Failed to parse AI JSON response:", completion.choices[0].message.content);
    if (task === 'next_action') {
      return {
        question: "My apologies, there was a slight issue. Let's try a different question: can you tell me about a project you're particularly proud of?"
      };
    }
    throw new Error("Failed to parse AI response as JSON.");
  }
}
// Start initialization tasks in the background.
initializeBuckets();
serve(app.fetch);
