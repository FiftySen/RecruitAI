/* AUTOGENERATED FILE - DO NOT EDIT CONTENTS */ /* Table schema:
CREATE TABLE kv_store_6ead2a10 (
  key TEXT NOT NULL PRIMARY KEY,
  value JSONB NOT NULL
);
*/ // View at https://supabase.com/dashboard/project/kjksyigqsvrpowxodnim/database/tables
// This file provides a simple key-value interface for storing Figma Make data. It should be adequate for most small-scale use cases.
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'npm:@supabase/supabase-js@2';
import { cors } from "npm:hono/cors";
import { Hono } from "npm:hono";
import { logger } from "npm:hono/logger";
import * as kv from './kv_store.tsx';
// --- IMPORTS for reliable file parsing ---
import pdf from "npm:pdf-parse";
import mammoth from "npm:mammoth";
const app = new Hono();
// Middleware
app.use('*', cors({
  origin: '*',
  allowMethods: [
    'GET',
    'POST',
    'PUT',
    'DELETE',
    'OPTIONS'
  ],
  allowHeaders: [
    'Content-Type',
    'Authorization'
  ]
}));
app.use('*', logger(console.log));
// Initialize Supabase clients
const supabaseUrl = Deno.env.get('SUPABASE_URL');
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');
const HUGGING_FACE_TOKEN = Deno.env.get('HUGGING_FACE_TOKEN');
const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);
const supabase = createClient(supabaseUrl, supabaseAnonKey);
// --- Scoring Logic using Hugging Face API ---
async function calculateSimilarityScores(resumeText, requirements) {
  console.log("DEBUG: Starting CHUNK-BASED similarity scoring...");
  // 1. Split the resume into smaller, more meaningful chunks (sentences).
  const resumeChunks = resumeText.split(/[.!?]/g).filter((s)=>s.trim().length > 10);
  console.log(`DEBUG: Split resume into ${resumeChunks.length} chunks.`);
  const allScores = [];
  // 2. For each requirement, find the best matching chunk in the resume.
  for (const requirement of requirements){
    const response = await fetch("https://api-inference.huggingface.co/models/sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2", {
      headers: {
        'Authorization': `Bearer ${HUGGING_FACE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      method: "POST",
      body: JSON.stringify({
        inputs: {
          // Compare the single requirement against ALL resume chunks at once.
          source_sentence: requirement,
          sentences: resumeChunks
        },
        options: {
          wait_for_model: true
        }
      })
    });
    if (!response.ok) {
      const errorBody = await response.text();
      console.error("DEBUG: Hugging Face API Error Response:", errorBody);
      throw new Error(`Hugging Face API error for requirement: "${requirement}"`);
    }
    const chunkSimilarities = await response.json();
    if (!Array.isArray(chunkSimilarities)) {
      throw new Error("Invalid response format from Hugging Face API");
    }
    // 3. The score for the requirement is the HIGHEST score found among all chunks.
    const bestScore = Math.max(...chunkSimilarities, 0);
    allScores.push(bestScore);
    console.log(`DEBUG: Best score for "${requirement}" is ${(bestScore * 100).toFixed(2)}%`);
  }
  return allScores;
}
function extractRequirements(job) {
  const requirements = [];
  // if (job.assessmentConfiguration) {
  //   const config = job.assessmentConfiguration;
  //   if (config.selectedTechnicalSubSkills) requirements.push(...config.selectedTechnicalSubSkills);
  //   if (config.selectedSoftSkillsSubAreas) requirements.push(...config.selectedSoftSkillsSubAreas);
  //   if (config.customTechnicalSkills) requirements.push(...config.customTechnicalSkills.split('\n').filter((s)=>s.trim()));
  //   if (config.customSoftSkills) requirements.push(...config.customSoftSkills.split('\n').filter((s)=>s.trim()));
  // }
  // if (job.requiredSkills) {
  //   if (job.requiredSkills.technical) requirements.push(...job.requiredSkills.technical);
  //   if (job.requiredSkills.softSkills) requirements.push(...job.requiredSkills.softSkills);
  //   if (job.requiredSkills.software) requirements.push(...job.requiredSkills.software);
  // }
  if (job.requirements) requirements.push(...job.requirements);
  return [
    ...new Set(requirements)
  ].filter((req)=>req && req.trim().length > 0);
}
async function updateApplicationScore(applicationKey, scoreData) {
  const application = await kv.get(applicationKey);
  if (application) {
    application.resumeScore = scoreData;
    application.resumeScoreStatus = 'completed';
    await kv.set(applicationKey, application);
  }
}
// --- CHANGED SECTION ---
// The function no longer needs userId, as all required data is on the application object.
async function scoreResumeInBackground(applicationKey, positionId) {
  console.log(`DEBUG: Starting background scoring for application: ${applicationKey}`);
  try {
    // 1. Fetch the job details to get the requirements
    const job = await kv.get(`job-position:${positionId}`);
    if (!job) throw new Error(`Failed to fetch job: ${positionId}`);
    console.log("DEBUG: Successfully fetched job details.");
    // 2. Fetch the specific application to get the correct resume text
    const application = await kv.get(applicationKey);
    if (!application) throw new Error(`Failed to fetch application: ${applicationKey}`);
    if (!application.resumeText) throw new Error('No resume text available in application');
    console.log("DEBUG: Successfully fetched application with resume text.");
    // 3. Extract all requirements from the job data
    const requirements = extractRequirements(job);
    if (requirements.length === 0) {
      console.log("DEBUG: No requirements found for this job. Setting default score.");
      await updateApplicationScore(applicationKey, {
        success: true,
        overallScore: 50,
        sectionScores: [],
        analysis: {
          overallScore: 50,
          strengths: [],
          improvements: [],
          detailedScores: [],
          message: "No specific requirements found for this position"
        }
      });
      return;
    }
    console.log(`DEBUG: Extracted ${requirements.length} requirements.`);
    const resumeText = application.resumeText;
    console.log("DEBUG: Resume text length:", resumeText.length);
    // 4. Get similarity scores from the AI model
    const similarities = await calculateSimilarityScores(resumeText, requirements);
    if (!similarities || similarities.length !== requirements.length) {
      throw new Error("Mismatch between requirements and returned similarity scores");
    }
    console.log("DEBUG: Similarity scores processed successfully.");
    // 5. Process the scores into a final result
    const sectionScores = requirements.map((req, index)=>{
      const similarity = similarities[index];
      const score = Math.max(0, Math.min(100, Math.round(similarity * 100)));
      return {
        requirement: req,
        score: score,
        matchPercentage: score
      };
    });
    const totalScore = sectionScores.reduce((sum, item)=>sum + item.score, 0);
    const finalScore = Math.round(totalScore / sectionScores.length);
    console.log(`DEBUG: Calculated final score: ${finalScore}%`);
    const strengths = sectionScores.filter((s)=>s.score >= 70).map((s)=>s.requirement);
    const improvements = sectionScores.filter((s)=>s.score < 40).map((s)=>s.requirement);
    const scoreData = {
      success: true,
      overallScore: finalScore,
      analysis: {
        strengths: strengths,
        improvements: improvements,
        detailedScores: sectionScores
      }
    };
    // 6. Save the final score back to the application object
    await updateApplicationScore(applicationKey, scoreData);
    console.log(`DEBUG: Successfully saved score for application: ${applicationKey}`);
  } catch (error) {
    // If anything above fails, catch the error and mark the scoring as 'failed'
    console.error('Background resume scoring failed:', error);
    const application = await kv.get(applicationKey);
    if (application) {
      application.resumeScoreStatus = 'failed';
      application.resumeScore = {
        success: false,
        error: error.message,
        overallScore: 0,
        analysis: {
          overallScore: 0
        }
      };
      await kv.set(applicationKey, application);
    }
  }
}
// --- Helper Functions ---
const initializeBuckets = async ()=>{
  const bucketName = 'make-6ead2a10-resumes';
  try {
    const { data: buckets } = await supabaseAdmin.storage.listBuckets();
    const bucketExists = buckets?.some((bucket)=>bucket.name === bucketName);
    if (!bucketExists) {
      const { error } = await supabaseAdmin.storage.createBucket(bucketName, {
        public: false,
        allowedMimeTypes: [
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        ],
        fileSizeLimit: 5242880 // 5MB
      });
      if (error) console.error('Error creating bucket:', error);
      else console.log('Resume bucket created successfully');
    }
  } catch (error) {
    console.error('Error initializing buckets:', error);
  }
};
const getByPrefixWithKeys = async (prefix)=>{
  const supabaseClient = createClient(Deno.env.get('SUPABASE_URL'), Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'));
  const { data, error } = await supabaseClient.from('kv_store_6ead2a10').select('key, value').like('key', prefix + '%');
  if (error) throw new Error(error.message);
  return data || [];
};
const extractTextFromFile = async (file)=>{
  try {
    console.log("DEBUG: Starting text extraction with robust libraries for file:", file.name, "Type:", file.type);
    const arrayBuffer = await file.arrayBuffer();
    let text = "";
    switch(file.type){
      case 'application/pdf':
        const pdfData = await pdf(arrayBuffer);
        text = pdfData.text;
        break;
      case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
        const docxData = await mammoth.extractRawText({
          arrayBuffer
        });
        text = docxData.value;
        break;
      case 'application/msword':
        console.warn("Attempting to parse legacy .doc format. Results may vary.");
        try {
          const docData = await mammoth.extractRawText({
            arrayBuffer
          });
          text = docData.value;
        } catch (docError) {
          console.error("Could not parse .doc file. It might be unsupported.", docError.message);
          throw new Error("Legacy .doc file format is not fully supported. Please convert to DOCX or PDF.");
        }
        break;
      case 'text/plain':
        text = new TextDecoder().decode(new Uint8Array(arrayBuffer));
        break;
      default:
        console.warn("Unsupported file type:", file.type);
        throw new Error(`Unsupported file format: ${file.type}. Please upload PDF or DOCX.`);
    }
    if (!text || text.trim().length < 20) {
      throw new Error("Extracted text was empty or too short. The document may be image-based or corrupt.");
    }
    const cleanedText = text.replace(/\s+/g, ' ').trim();
    console.log(`DEBUG: Successfully extracted text. Length: ${cleanedText.length}. Sample: ${cleanedText.substring(0, 150)}...`);
    return cleanedText;
  } catch (error) {
    console.error('Error extracting text from file:', error);
    throw new Error(`Failed to parse the resume file: ${error.message}`);
  }
};
const verifyAdminRole = async (accessToken)=>{
  if (!accessToken) return {
    isAdmin: false,
    user: null,
    error: 'No access token provided'
  };
  try {
    const { data: { user }, error } = await supabaseAdmin.auth.getUser(accessToken);
    if (error || !user?.id) return {
      isAdmin: false,
      user: null,
      error: 'Invalid access token'
    };
    let profile = await kv.get(`profile:${user.id}`);
    if (!profile) {
      profile = {
        name: user.user_metadata?.name || user.email?.split('@')[0],
        email: user.email,
        role: 'candidate',
        createdAt: new Date().toISOString()
      };
      await kv.set(`profile:${user.id}`, profile);
    }
    return {
      isAdmin: profile.role === 'admin',
      user,
      error: null
    };
  } catch (error) {
    console.error('Admin verification error:', error);
    return {
      isAdmin: false,
      user: null,
      error: 'Failed to verify admin role'
    };
  }
};
// --- Main Server Endpoints ---
app.post('/make-server-6ead2a10/apply-for-job', async (c)=>{
  try {
    // --- CHANGED SECTION ---
    // The endpoint now accepts `resumeText` directly.
    // The frontend should get this text from the `/upload-resume` response.
    const { userId, positionId, resumeUrl, resumeText } = await c.req.json();
    if (!userId || !positionId || !resumeText) {
      return c.json({
        error: 'User ID, Position ID, and Resume Text are required'
      }, 400);
    }
    const applicationKey = `job-application:${positionId}:${userId}`;
    const applicationData = {
      userId,
      positionId,
      appliedAt: new Date().toISOString(),
      status: 'pending',
      resumeUrl,
      resumeText,
      resumeScoreStatus: 'pending'
    };
    await kv.set(applicationKey, applicationData);
    // CHANGED: No longer need to pass userId
    scoreResumeInBackground(applicationKey, positionId);
    return c.json({
      success: true,
      application: applicationData
    });
  } catch (error) {
    console.error('Apply for job error:', error);
    return c.json({
      error: 'Failed to apply for job'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/signup', async (c)=>{
  try {
    const { email, password, name, role = 'candidate' } = await c.req.json();
    if (!email || !password || !name) return c.json({
      error: 'Email, password, and name are required'
    }, 400);
    if (role !== 'candidate') return c.json({
      error: 'Only candidate accounts can be created through public signup'
    }, 400);
    const { data, error } = await supabaseAdmin.auth.admin.createUser({
      email,
      password,
      user_metadata: {
        name
      },
      email_confirm: true
    });
    if (error) throw error;
    if (data.user) {
      await kv.set(`profile:${data.user.id}`, {
        name,
        email,
        role,
        createdAt: new Date().toISOString()
      });
    }
    return c.json({
      success: true,
      user: data.user
    });
  } catch (error) {
    console.error('Signup error:', error);
    return c.json({
      error: error.message
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-user-role', async (c)=>{
  try {
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    let profile = await kv.get(`profile:${userId}`);
    if (!profile) {
      const { data: { user }, error } = await supabaseAdmin.auth.admin.getUserById(userId);
      if (error || !user) throw new Error('User not found');
      profile = {
        name: user.user_metadata?.name || user.email?.split('@')[0],
        email: user.email,
        role: 'candidate',
        createdAt: new Date().toISOString()
      };
      await kv.set(`profile:${userId}`, profile);
    }
    return c.json({
      role: profile.role || 'candidate'
    });
  } catch (error) {
    console.error('Get user role error:', error);
    return c.json({
      error: error.message
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-profile', async (c)=>{
  try {
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    const profile = await kv.get(`profile:${userId}`);
    return c.json({
      profile
    });
  } catch (error) {
    console.error('Get profile error:', error);
    return c.json({
      error: 'Failed to retrieve profile'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/save-profile', async (c)=>{
  try {
    const { userId, profile } = await c.req.json();
    if (!userId || !profile) return c.json({
      error: 'User ID and profile data are required'
    }, 400);
    profile.updatedAt = new Date().toISOString();
    await kv.set(`profile:${userId}`, profile);
    return c.json({
      success: true
    });
  } catch (error) {
    console.error('Save profile error:', error);
    return c.json({
      error: 'Failed to save profile'
    }, 500);
  }
});
app.get('/make-server-6ead2a10/get-job-positions', async (c)=>{
  try {
    const positions = await getByPrefixWithKeys('job-position:');
    const positionsData = positions.map((p)=>({
        id: p.key.split(':')[1],
        ...p.value
      })).filter(Boolean);
    return c.json({
      positions: positionsData
    });
  } catch (error) {
    console.error('Get job positions error:', error);
    return c.json({
      error: 'Failed to retrieve job positions'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-job-position', async (c)=>{
  try {
    const { positionId } = await c.req.json();
    if (!positionId) return c.json({
      error: 'Position ID is required'
    }, 400);
    const position = await kv.get(`job-position:${positionId}`);
    if (!position) return c.json({
      error: 'Job position not found'
    }, 404);
    return c.json({
      position: {
        id: positionId,
        ...position
      }
    });
  } catch (error) {
    console.error('Get job position error:', error);
    return c.json({
      error: 'Failed to retrieve job position'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/save-job-position', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin, user } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId, position } = await c.req.json();
    if (!position) return c.json({
      error: 'Position data is required'
    }, 400);
    // Keep the validation to ensure the main requirements field is always present
    if (!position.requirements || !Array.isArray(position.requirements) || position.requirements.length === 0) {
      return c.json({
        error: 'The requirements field is missing or empty. Please provide at least one requirement.'
      }, 400);
    }
    const id = positionId || `pos_${Date.now()}`;
    const positionData = {
      ...position,
      id,
      createdAt: position.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      createdBy: user.id
    };
    await kv.set(`job-position:${id}`, positionData);
    return c.json({
      success: true,
      position: positionData
    });
  } catch (error) {
    console.error('Save job position error:', error);
    return c.json({
      error: 'Failed to save job position'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/delete-job-position', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId } = await c.req.json();
    if (!positionId) return c.json({
      error: 'Position ID is required'
    }, 400);
    await kv.del(`job-position:${positionId}`);
    const applications = await getByPrefixWithKeys(`job-application:${positionId}:`);
    for (const app of applications)if (app.key) await kv.del(app.key);
    return c.json({
      success: true
    });
  } catch (error) {
    console.error('Delete job position error:', error);
    return c.json({
      error: 'Failed to delete job position'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/upload-resume', async (c)=>{
  try {
    const formData = await c.req.formData();
    const file = formData.get('resume');
    const userId = formData.get('userId');
    if (!file || !userId) return c.json({
      error: 'Resume file and user ID are required'
    }, 400);
    const fileExtension = file.name.split('.').pop();
    const fileName = `resume_${Date.now()}.${fileExtension}`;
    const filePath = `${userId}/${fileName}`;
    const fileBuffer = await file.arrayBuffer();
    const { error: uploadError } = await supabaseAdmin.storage.from('make-6ead2a10-resumes').upload(filePath, fileBuffer, {
      contentType: file.type,
      upsert: true
    });
    if (uploadError) throw uploadError;
    const resumeText = await extractTextFromFile(file);
    const profile = await kv.get(`profile:${userId}`) || {};
    // Note: We still update the profile's resume_text for convenience,
    // but the application scoring no longer depends on it.
    Object.assign(profile, {
      resumeUrl: filePath,
      resumeFileName: file.name,
      resumeUploadedAt: new Date().toISOString(),
      resume_text: resumeText
    });
    await kv.set(`profile:${userId}`, profile);
    // --- CHANGED SECTION ---
    // Return the extracted text along with the URL.
    return c.json({
      success: true,
      resumeUrl: filePath,
      resumeText: resumeText
    });
  } catch (error) {
    console.error('Upload resume error:', error);
    return c.json({
      error: error.message
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-user-applications', async (c)=>{
  try {
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    const allApplications = await getByPrefixWithKeys('job-application:');
    const userApplications = allApplications.filter((app)=>app.value?.userId === userId);
    const applicationsWithPositions = await Promise.all(userApplications.map(async (app)=>{
      if (app.value && app.value.positionId) {
        const position = await kv.get(`job-position:${app.value.positionId}`);
        return {
          ...app.value,
          position: position ? {
            id: app.value.positionId,
            ...position
          } : null
        };
      }
      return null;
    }));
    return c.json({
      applications: applicationsWithPositions.filter(Boolean)
    });
  } catch (error) {
    console.error('Get user applications error:', error);
    return c.json({
      error: 'Failed to retrieve applications'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-ranked-candidates', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId } = await c.req.json();
    if (!positionId) return c.json({
      error: 'Position ID is required'
    }, 400);
    const position = await kv.get(`job-position:${positionId}`);
    if (!position) return c.json({
      error: 'Job position not found'
    }, 404);
    const applications = await getByPrefixWithKeys(`job-application:${positionId}:`);
    const candidates = await Promise.all(applications.map(async (app)=>{
      if (app.value?.userId) {
        const { userId } = app.value;
        const profile = await kv.get(`profile:${userId}`);
        const scores = {
          softSkills: 0,
          technical: 0,
          weighted: 0
        }; // Placeholder
        return {
          userId,
          profile,
          application: app.value,
          scores,
          resumeScore: app.value.resumeScore
        };
      }
      return null;
    }));
    const rankedCandidates = candidates.filter(Boolean).sort((a, b)=>b.scores.weighted - a.scores.weighted);
    return c.json({
      position: {
        id: positionId,
        ...position
      },
      candidates: rankedCandidates,
      totalCandidates: rankedCandidates.length
    });
  } catch (error) {
    console.error('Get ranked candidates error:', error);
    return c.json({
      error: 'Failed to retrieve ranked candidates'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/get-resume-url', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { userId } = await c.req.json();
    if (!userId) return c.json({
      error: 'User ID is required'
    }, 400);
    const profile = await kv.get(`profile:${userId}`);
    if (!profile?.resumeUrl) return c.json({
      error: 'No resume found'
    }, 404);
    const { data, error: urlError } = await supabaseAdmin.storage.from('make-6ead2a10-resumes').createSignedUrl(profile.resumeUrl, 3600);
    if (urlError) throw urlError;
    return c.json({
      resumeUrl: data.signedUrl
    });
  } catch (error) {
    console.error('Get resume URL error:', error);
    return c.json({
      error: 'Failed to get resume URL'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/update-application-status', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin, user } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { userId, positionId, status } = await c.req.json();
    if (!userId || !positionId || !status) return c.json({
      error: 'User ID, position ID, and status are required'
    }, 400);
    const application = await kv.get(`job-application:${positionId}:${userId}`);
    if (!application) return c.json({
      error: 'Application not found'
    }, 404);
    Object.assign(application, {
      status,
      updatedAt: new Date().toISOString(),
      updatedBy: user.id
    });
    await kv.set(`job-application:${positionId}:${userId}`, application);
    return c.json({
      success: true,
      application
    });
  } catch (error) {
    console.error('Update application status error:', error);
    return c.json({
      error: 'Failed to update application status'
    }, 500);
  }
});
app.post('/make-server-6ead2a10/update-job-status', async (c)=>{
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    const { isAdmin } = await verifyAdminRole(accessToken);
    if (!isAdmin) return c.json({
      error: 'Unauthorized'
    }, 401);
    const { positionId, status } = await c.req.json();
    if (!positionId || !status) return c.json({
      error: 'Position ID and status are required'
    }, 400);
    const position = await kv.get(`job-position:${positionId}`);
    if (!position) return c.json({
      error: 'Job position not found'
    }, 404);
    position.status = status;
    position.updatedAt = new Date().toISOString();
    await kv.set(`job-position:${positionId}`, position);
    return c.json({
      success: true,
      position
    });
  } catch (error) {
    console.error('Update job status error:', error);
    return c.json({
      error: 'Failed to update job status'
    }, 500);
  }
});
// --- NEW ENDPOINT 1: Start the Assessment ---
app.post('/make-server-6ead2a10/start-assessment', async (c)=>{
  try {
    const { userId, positionId } = await c.req.json();
    const applicationKey = `job-application:${positionId}:${userId}`;
    // 1. Fetch job and resume data
    const job = await kv.get(`job-position:${positionId}`);
    const application = await kv.get(applicationKey);
    if (!job || !application || !application.resumeText) {
      throw new Error('Job or application data not found.');
    }
    // 2. Create a new assessment session
    const sessionKey = `assessment-session:${applicationKey}`;
    const session = {
      jobRole: job.title,
      assessmentCriteria: job.assessmentConfiguration?.selectedTechnicalSubSkills || [],
      resumeText: application.resumeText,
      conversationHistory: [],
      questionCount: 0
    };
    await kv.set(sessionKey, session);
    // 3. Get the FIRST question from the AI
    // NOTE: callAIAssessment is a new helper function we will create
    const aiResponse = await callAIAssessment('next_action', session);
    return c.json({
      sessionKey,
      firstQuestion: aiResponse.question
    });
  } catch (error) {
    console.error('Error starting assessment:', error);
    return c.json({
      error: 'Failed to start assessment'
    }, 500);
  }
});
// --- NEW ENDPOINT 2: Handle Each Answer ---
app.post('/make-server-6ead2a10/submit-answer', async (c)=>{
  try {
    const { sessionKey, answer } = await c.req.json();
    const session = await kv.get(sessionKey);
    if (!session) throw new Error('Assessment session not found.');
    // 1. Update history and question count
    session.conversationHistory.push({
      speaker: 'ai',
      text: session.lastQuestion
    });
    session.conversationHistory.push({
      speaker: 'user',
      text: answer
    });
    session.questionCount += 1;
    if (session.questionCount >= 10) {
      // 2. Interview is over: generate the final report
      const report = await callAIAssessment('generate_report', session);
      // Save report to the main application object
      const applicationKey = sessionKey.replace('assessment-session:', '');
      const application = await kv.get(applicationKey);
      if (application) {
        application.assessmentReport = report;
        application.status = 'under_review'; // Or another status
        await kv.set(applicationKey, application);
      }
      await kv.del(sessionKey); // Clean up the session
      return c.json({
        status: 'completed'
      });
    } else {
      // 3. Interview continues: get the next question
      const aiResponse = await callAIAssessment('next_action', session);
      session.lastQuestion = aiResponse.question; // Remember the last question asked
      await kv.set(sessionKey, session);
      return c.json({
        status: 'in_progress',
        nextQuestion: aiResponse.question
      });
    }
  } catch (error) {
    console.error('Error submitting answer:', error);
    return c.json({
      error: 'Failed to process answer'
    }, 500);
  }
});
// --- NEW HELPER FUNCTION: Call Your Fine-Tuned AI ---
async function callAIAssessment(task, session) {
  const DEEPSEEK_API_URL = "your-deployed-deepseek-api-url"; // From Hugging Face or Colab
  const HF_TOKEN = Deno.env.get('HF_TOKEN'); // Store your token securely
  let instruction = "";
  if (task === 'next_action') {
    instruction = "You are an expert AI interviewer. Given the job role, assessment criteria, candidate's resume, and the conversation so far, decide the best next question to ask...";
  } else {
    instruction = "You are an AI evaluator. Based on the job criteria, the candidate's resume, and the full interview transcript, generate a comprehensive performance report in JSON format...";
  }
  const response = await fetch(DEEPSEEK_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${HF_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      inputs: {
        instruction,
        input: session
      } // This matches the training format
    })
  });
  if (!response.ok) throw new Error('AI model API call failed');
  return response.json();
}
// Start initialization tasks in the background.
initializeBuckets();
serve(app.fetch);
